import { createAsyncThunk, createSlice } from '@reduxjs/toolkit';
import { ethers } from "ethers";
import MarketplaceAbi from '../../abis/Marketplace.json';
import MarketplaceAddress from '../../abis//Marketplace-address.json';
import NFTAbi from '../../abis/NFT.json';
import NFTAddress from '../../abis/NFT-address.json';
import { RootState } from '../store';

export interface Web3State {
    nft: any;
    marketplace: any;
    selectedAccount: string;
    status: 'idle' | 'loading' | 'failed';
  }
  
const initialState: Web3State = {
    nft: null,
    marketplace: null,
    selectedAccount: '',
    status: 'idle',
};

export const setWeb3HandlerAsync = createAsyncThunk(
    'web3/setWeb3Handler',
    async () => {
        // The value we return becomes the `fulfilled` action payload

        window.ethereum.on('chainChanged', () => {
            window.location.reload();
        });

        window.ethereum.on('accountsChanged', async function (accounts:string[]) {
            window.location.reload();
        });

        let account = await window.ethereum.selectedAddress;
        const provider = new ethers.providers.Web3Provider(window.ethereum);
        const signer = provider.getSigner();
        const selectedAccount = account?.toString().toUpperCase();
        
        provider.getCode(MarketplaceAddress.address).then((res) => {
        });

        const marketplace = new ethers.Contract(MarketplaceAddress.address, MarketplaceAbi.abi, signer);
        const nft = new ethers.Contract(NFTAddress.address, NFTAbi.abi, signer);
        
        return {
            nft,
            marketplace,
            selectedAccount
        };
    }
);

export const web3Slice = createSlice({
    name: 'web3',
    initialState,
    // The `reducers` field lets us define reducers and generate associated actions
    reducers: {
    //   setItemList: (state, action: PayloadAction<IItem[]>) => {
    //     state.value = action.payload;
    //   },
    },
    //extraReducers: (builder) ... for the async function
    // The `extraReducers` field lets the slice handle actions defined elsewhere,
  // including actions generated by createAsyncThunk or in other slices.
    extraReducers: (builder) => {
      builder
        .addCase(setWeb3HandlerAsync.pending, (state) => {
          state.status = 'loading';
        })
        .addCase(setWeb3HandlerAsync.fulfilled, (state, action) => {
          state.status = 'idle';
          
          state.nft = action.payload.nft;
          state.marketplace = action.payload.marketplace;
          state.selectedAccount = action.payload.selectedAccount;
        })
        .addCase(setWeb3HandlerAsync.rejected, (state) => {
          state.status = 'failed';
        });
    },
  });

  export default web3Slice.reducer;

  export const getSelectedAccount = (state: RootState) => state.web3.selectedAccount;
  export const getMarketplaceContract = (state: RootState) => state.web3.marketplace;
  export const getNftContract = (state: RootState) => state.web3.nft;
